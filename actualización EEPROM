//EEPROM
void writeAngleToRegister(int address, byte valor) {
  // Escribe el ángulo en el registro de la dirección especificada
  while (EECR & (1 << EEPE));
  EECR = (0 << EEPM1) | (0 << EEPM0);
  EEAR = address;
  EEDR = valor;
  EECR |= (1 << EEMPE);
  EECR |= (1 << EEPE);
  
}

byte readAngleFromRegister(int address) {
  // Lee el ángulo del registro de la dirección especificada
  while (EECR & (1 << EEPE));
  EEAR = address;
  EECR |= (1 << EERE);
  return EEDR;
}

//variables utilizadas en la lectura de los angulos de los potenciometros 
int angle0 = 0;
int angle1 = 0;
int angle2 = 0;
int angle3 = 0;


void loop() {

  //Siempre y cuando esté apachado el botón del pin 3, corre esta parte que deja mover el potenciómetro para cambiar el ángulo del servo.
  // Si se apacha el botón rojo mientras se tiene apachado el botón del pin 3, se guarda el valor del ángulo en la eeprom.
  //Esto se repite para los demas potenciometros  
while (!(PIND & (1 << DDD3))) {
  // Enviar el valor '1' a través de la comunicación serial
   Serial.write('1');
    

    // Conversión ADC para potenciómetros 
    ADMUX &= 0xF0; // Limpieza de los bits MUX
    ADMUX |= 0b00000;  // Pin A0
    ADCSRA |= (1 << ADSC);  // Iniciar la conversión de la entrada analógica a digital
    while (ADCSRA & (1 << ADSC)); // Esperar a que la conversión termine
    // Leer el valor ADC del potenciómetro
    int potValue0 = ADC; 
    // Utilizar una función de mapeo para controlar la posición del servomotor en función de la entrada analógica del potenciómetro 
    angle0 = map(potValue0, 0, 1023, 0, 90);
    servoA.write(angle0);
    if (!(PIND & (1 << DDD2))) {
      writeAngleToRegister(0, angle0);
    }
    delay(200);
  

    // Conversión ADC para potenciómetros 
    ADMUX &= 0xF0; // Limpieza de los bits MUX
    ADMUX |= 0b00001;  // Pin A1
    ADCSRA |= (1 << ADSC);  // Iniciar la conversión de la entrada analógica a digital
    while (ADCSRA & (1 << ADSC)); // Esperar a que la conversión termine
    // Leer el valor ADC del potenciómetro
    int potValue1 = ADC; 
    // Utilizar una función de mapeo para controlar la posición del servomotor en función de la entrada analógica del potenciómetro 
    angle1 = map(potValue1, 0, 1023, 0, 140);
    servoB.write(angle1);
    if (!(PIND & (1 << DDD2))) {
      writeAngleToRegister(1, angle1);
    }
    delay(200);
  
    // Conversión ADC para potenciómetros 
    ADMUX &= 0xF0; // Limpieza de los bits MUX
    ADMUX |= 0b00010;  // Pin A2
    ADCSRA |= (1 << ADSC);  // Iniciar la conversión de la entrada analógica a digital
    while (ADCSRA & (1 << ADSC)); // Esperar a que la conversión termine
    // Leer el valor ADC del potenciómetro
    int potValue2 = ADC; 
    // Utilizar una función de mapeo para controlar la posición del servomotor en función de la entrada analógica del potenciómetro 
    angle2 = map(potValue2, 0, 1023, 0, 120);
    servoC.write(angle2);
    if (!(PIND & (1 << DDD2))) {
      writeAngleToRegister(2, angle2);
    }
    delay(200);

    // Conversión ADC para potenciómetros 
    ADMUX &= 0xF0; // Limpieza de los bits MUX
    ADMUX |= 0b00011;  // Pin A3
    ADCSRA |= (1 << ADSC);  // Iniciar la conversión de la entrada analógica a digital
    while (ADCSRA & (1 << ADSC)); // Esperar a que la conversión termine
    // Leer el valor ADC del potenciómetro
    int potValue3 = ADC; 
    // Utilizar una función de mapeo para controlar la posición del servomotor en función de la entrada analógica del potenciómetro 
    angle3 = map(potValue3, 0, 1023, 0, 130);
    servoD.write(angle3);
    if (!(PIND & (1 << DDD2))) {
      writeAngleToRegister(3, angle3);
    }
    delay(200);
  }

  //Si se presiona el boton digital 2 se utiliza EEPROM 
    while (!(PIND & (1 << DDD2))) {
    // Enviar el valor '2' a través de la comunicación serial
    Serial.write('2');

    servoA.write(readAngleFromRegister(0));
    servoB.write(readAngleFromRegister(1));
    servoC.write(readAngleFromRegister(2));
    servoD.write(readAngleFromRegister(3));

    delay(200);
  }
  }
